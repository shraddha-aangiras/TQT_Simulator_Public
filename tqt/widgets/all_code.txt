
------------------
FILE: __init__.py
------------------
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QPalette, QColor

# A dark mode palette to reduce excess light from screen in a dark optics lab
palette = QPalette()
palette.setColor(QPalette.Window, QColor(53, 53, 53))
palette.setColor(QPalette.WindowText, Qt.white)
palette.setColor(QPalette.Base, QColor(25, 25, 25))
palette.setColor(QPalette.AlternateBase, QColor(53, 53, 53))
palette.setColor(QPalette.ToolTipBase, Qt.black)
palette.setColor(QPalette.ToolTipText, Qt.white)
palette.setColor(QPalette.Text, Qt.white)
palette.setColor(QPalette.Button, QColor(53, 53, 53))
palette.setColor(QPalette.ButtonText, Qt.white)
palette.setColor(QPalette.BrightText, Qt.red)
palette.setColor(QPalette.Link, QColor(42, 130, 218))
palette.setColor(QPalette.Highlight, QColor(42, 130, 218))
palette.setColor(QPalette.HighlightedText, Qt.black)

------------------
FILE: plot_counts.py
------------------
from PyQt5.QtWidgets import (
    QPushButton,
    QWidget,
    QGridLayout,
    QLabel,
    QHBoxLayout,
    QVBoxLayout,
)
from PyQt5.QtGui import QFont

import pyqtgraph as pg
from pyqtgraph.functions import mkPen

import numpy as np


class PlotLogicGrid(QWidget):
    def __init__(self, parent, timetagger, ui_config=None, num_plot_widgets=6):
        super(QWidget, self).__init__(parent)
        self.timetagger = timetagger
        self.ui_config = ui_config

        layout = QGridLayout()
        self.plots = [
            PlotLogic(self, timetagger, ui_config, default_logic_int=j + 1)
            for j in range(num_plot_widgets)
        ]
        for i, plot in enumerate(self.plots):
            layout.addWidget(plot, i, 1)

        self.setLayout(layout)

    def update_grid(self):
        duration_s = self.ui_config["INTEGRATION_TIME_MS"] / 1000.0
        self.timetagger.read(duration_s)  # read the data from the time tagger once per loop
        for i, plot in enumerate(self.plots):
            plot.onNewData()


class PlotLogic(QWidget):
    def __init__(self, parent, timetagger, ui_config, default_logic_int=0):
        super(QWidget, self).__init__(parent)
        self.timetagger = timetagger
        self.ui_config = ui_config

        layout = QHBoxLayout()

        self.add_plot = True

        # add row of checkboxes to set pattern
        self.count_value = QLabel(f"{round(0)}")
        width = 100
        self.count_value.setMaximumWidth(width)
        self.count_value.setMinimumWidth(width)
        self.count_value.setFont(QFont("Arial", ui_config["NUMERIC_FONT_SIZE"]))
        layout.addWidget(self.count_value)

        self.logic_pattern_buttons = []
        button_layout = QHBoxLayout()
        plot_button_layout = QVBoxLayout()

        default_pattern = list(reversed("{0:016b}".format(default_logic_int)))

        for i in range(
            16
        ):  # loop through the 16 channels on the time tagger and add a button for each
            btn = TimeTaggerPatternButton(self)
            btn.setMinimumWidth(20)
            self.logic_pattern_buttons.append(btn)
            btn.clicked.connect(btn.callback)
            if default_pattern[i] == "1":
                btn.callback()
            button_layout.addWidget(btn)
        plot_button_layout.addLayout(button_layout)

        if self.add_plot:
            # plot initialization
            self.plot = pg.PlotWidget()
            self.plot.setLabel("left", "(Counts)")
            self.plot.time = [0]
            self.plot.data = [0]
            self.plot.getAxis("bottom").setTicks([])

            self.ylim = [0, 1]

            self.data = {
                "x": list(np.linspace(-10, 0, self.ui_config["NUMBER_POINTS_MEM"])),
                "y": list(np.zeros(self.ui_config["NUMBER_POINTS_MEM"])),
            }
            self.line = self.plot.plot(
                self.data["x"],
                self.data["y"],
                pen=mkPen(color=self.ui_config["COLORS"][1]),
            )
            plot_button_layout.addWidget(
                self.plot
            )  # 16 is for the number of channels on the time tagger

        layout.addLayout(plot_button_layout)
        self.setLayout(layout)

    def onNewData(self):
        # create binary pattern for the logic pattern to plot
        channels = []
        for ch, btn in enumerate(self.logic_pattern_buttons, 1):
            if btn.curr_value == 1:
                channels.append(ch)

        dt, counts, rate = self.timetagger.get_count_data(channels)

        # update this value with the one from the logic pattern
        new_count_value = round(counts)

        # set the label text to the current value
        self.count_value.setText(f"{new_count_value}")

        # add the current count value to the plot
        yscaling = "auto"
        if self.add_plot:
            # update with the most recent count value
            self.update_array(
                self.data["y"], new_count_value, self.ui_config["NUMBER_POINTS_MEM"]
            )
            self.line.setData(self.data["x"], self.data["y"])

            # set upper ylim to the largest value seen
            if yscaling == "auto":
                self.ylim[1] = np.max(self.data["y"])

            elif yscaling == "max-mem":
                if new_count_value > self.ylim[1]:
                    self.ylim[1] = new_count_value
            self.plot.setYRange(self.ylim[0], self.ylim[1])

        return

    @staticmethod
    def update_array(array, new_value, size):
        array.append(new_value)
        if len(array) >= size:
            array.pop(0)
        return


class TimeTaggerPatternButton(QPushButton):
    def __init__(self, parent):
        super(QPushButton, self).__init__(parent)
        self.curr_value = 0
        self.labels = (" ", "+")
        self.set_background_and_label()

    def callback(self):
        self.curr_value = (
            self.curr_value + 1
        ) % 2  # cycle through 0 and 1 everytime it is clicked
        self.set_background_and_label()

    def set_background_and_label(self):
        label = self.labels[self.curr_value]
        self.setText(label)
        if self.curr_value == 1:  # AND logic pattern for this channel
            self.setStyleSheet("background-color : #7299ba")
        else:
            self.setStyleSheet("background-color : #cfcfcf")

------------------
FILE: set_delays_thresholds.py
------------------
from PyQt5.QtWidgets import QWidget, QGridLayout, QLabel, QLineEdit


class SetDelaysThresholds(QWidget):
    def __init__(self, parent, system, ui_config):
        super(QWidget, self).__init__(parent)
        self.system = system
        self.ui_config = ui_config

        layout = QGridLayout()
        layout.setColumnStretch(1, 1)
        layout.setRowStretch(1, 1)

        layout.addWidget(QLabel(f"Delays (ns)"), 2, 1)  # channel number labels
        layout.addWidget(QLabel(f"Thresholds (??)"), 3, 1)  # channel number labels

        self.delay_edits = []
        self.threshold_edits = []
        for channel, (threshold, delay) in enumerate(
            zip(
                self.system.config["TIMETAGGER_CHANNEL_THRESHOLDS"],
                self.system.config["TIMETAGGER_CHANNEL_DELAYS"],
            )
        ):
            layout.addWidget(
                QLabel(f"Channel {channel+1}"), 1, channel + 2
            )  # channel number labels

            delay_edit = QLineEdit(f"{delay}")
            delay_edit.returnPressed.connect(self.update_delays)
            self.delay_edits.append(delay_edit)
            layout.addWidget(delay_edit, 2, channel + 2)  # delays

            threshold_edit = QLineEdit(f"{threshold}")
            threshold_edit.returnPressed.connect(self.update_thresholds)
            self.threshold_edits.append(threshold_edit)
            layout.addWidget(threshold_edit, 3, channel + 2)  # thresholds

        # layout.setRowStretch(
        #     layout.rowCount(), layout.columnCount()
        # )  # removes weird stretching by allowing space on the bottom
        self.setLayout(layout)

    def update_delays(self):
        new_delays = []
        for delay_edit in self.delay_edits:
            delay_str = delay_edit.text()
            delay_num = float(delay_str)
            new_delays.append(delay_num)
        self.system.set_timetagger_delays(new_delays)

    def update_thresholds(self):
        new_thresholds = []
        for threshold_edit in self.threshold_edits:
            threshold_str = threshold_edit.text()
            threshold_num = float(threshold_str)
            new_thresholds.append(threshold_num)
        self.system.set_timetagger_thresholds(new_thresholds)

------------------
FILE: slider_edit.py
------------------
from PyQt5 import Qt, QtCore
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QSlider, QDoubleSpinBox


class SliderWithEdit(QWidget):
    def __init__(self, parent, min=0, max=100, step=1, unit="mW"):
        super(QWidget, self).__init__(parent)

        # SCALING FACTOR: Allows slider to handle decimals (e.g. 0.5)
        # 0.5 input * 100 scale = 50 integer steps
        self.scale = 100 

        layout = QVBoxLayout()

        self.slider = QSlider(QtCore.Qt.Horizontal) # Added Horizontal for better look
        self.slider.valueChanged.connect(self.slider_changed)
        
        # Scale the inputs for the slider (int only)
        self.slider.setMinimum(int(min * self.scale))
        self.slider.setMaximum(int(max * self.scale))
        self.slider.setSingleStep(int(step * self.scale))
        self.slider.setTickInterval(int(step * self.scale))

        self.edit = QDoubleSpinBox(self)
        self.edit.valueChanged.connect(self.spinbox_changed)
        self.edit.setSuffix(f" {unit}")

        # Spinbox keeps the original float values
        self.edit.setMinimum(min)
        self.edit.setMaximum(max)
        self.edit.setSingleStep(step)

        layout.addWidget(self.edit)
        layout.addWidget(self.slider)

        layout.addStretch()
        self.setLayout(layout)

    def slider_changed(self):
        # Convert Slider (Int) -> SpinBox (Float)
        value = self.slider.value() / self.scale
        # Block signals to prevent infinite loops between slider and spinbox
        self.edit.blockSignals(True)
        self.edit.setValue(value)
        self.edit.blockSignals(False)

    def spinbox_changed(self):
        # Convert SpinBox (Float) -> Slider (Int)
        value = self.edit.value() * self.scale
        self.slider.blockSignals(True)
        self.slider.setValue(int(value))
        self.slider.blockSignals(False)

    def value(self):
        return self.edit.value()

    def setValue(self, val):
        self.edit.setValue(float(val))
        self.slider.setValue(int(val * self.scale))